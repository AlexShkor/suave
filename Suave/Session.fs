/// The session module has two components; the stateless 'authed' component
/// which sets a http-only cookie and verifies its signature/hmac matches that
/// which is generated by the server, and another component, the stateless,
/// which also maintains a stateful Map<string, obj> of data for the user's
/// session id.
module Suave.Session

open System
open System.Collections.Concurrent
open System.Security.Cryptography
open System.Text
open System.Runtime.Caching
open Types
open Http

[<Literal>]
let SessionAuthCookie = "auth"

/// This is the cookie that the client-side can use to check whether the
/// user is logged on or not. It's only a marker, which is used for this
/// purpose; the real auth cookie is the SessionHttpCookie, which isn't
/// available to client-side.
[<Literal>]
let SessionIdCookie = "sid"

module internal Utils =
  /// This is used to pack base64 in a cookie; generates a degenerated base64 string
  let base64_headers bytes =
    let base64 = Convert.ToBase64String bytes
    base64.Replace('+','-').Replace('/','_').Trim([| '=' |])

/// Use to set a session-id for the client, which is a way is how the client
/// is 'authenticated'.
module Auth =

  [<Literal>]
  let ServerKeyLength = 64

  [<Literal>]
  let SessionIdLength = 40

  /// Extracts the actual session id and the mac value from the cookie's data.
  let private parse_cookie_data (cd : string) =
    if cd.Length <= SessionIdLength then
      None
    else
      let id  = cd.Substring(0, SessionIdLength)
      let mac = cd.Substring(SessionIdLength)
      Some (id, mac)

  /// Returns a list of the hmac data to use, from the request.
  let private hmac_data session_id (request : HttpRequest) =
    [ session_id
      request.ipaddr.ToString()
      request.headers %% "user-agent" |> Option.or_default ""
    ]

  /// Set +relative_expiry time span on the expiry time of the cookies
  let private sliding_expiry relative_expiry auth_cookie client_cookie =
    let expiry = Globals.utc_now().Add relative_expiry
    { auth_cookie   with expires = Some expiry },
    { client_cookie with expires = Some expiry }

  /// The key used in `context.user_state` to save the session id for downstream
  /// web parts.
  [<Literal>]
  let SessionAuth = "Suave.Session.Auth"

  let private client_cookie session_id =
    { HttpCookie.mk' SessionIdCookie session_id with http_only = false }

  /// Generate one server auth-side cookie and one client-side cookie.
  let generate_cookies relative_expiry { request = req; runtime = run } =
    let session_id  = Crypto.generate_key' SessionIdLength
    let hmac_data   = hmac_data session_id req
    let hmac        = Crypto.hmac' run.server_key hmac_data |> Utils.base64_headers
    let cookie_data = String.Concat [| session_id; hmac |]
    let auth_cookie, client_cookie =
      sliding_expiry relative_expiry
        { HttpCookie.mk' SessionAuthCookie cookie_data with http_only = true }
        (client_cookie session_id)
    auth_cookie, client_cookie, session_id

  let unset_cookies (auth_cookie, client_cookie, session_id) : WebPart =
    Writers.unset_cookie auth_cookie >>=
      Writers.unset_cookie client_cookie >>=
      Writers.unset_user_data session_id

  /// Sets the http-cookie, the client-cookie and sets the value of SessionAuth
  /// in the user_data of the HttpContext.
  let set_cookies (auth_cookie, client_cookie, session_id) : WebPart =
    Writers.set_cookie auth_cookie >>=
      Writers.set_cookie client_cookie >>=
      Writers.set_user_data SessionAuth session_id

  let refresh_cookies relative_expiry auth_cookie session_id : WebPart =
    let a', c' = sliding_expiry relative_expiry auth_cookie (client_cookie session_id)
    set_cookies (a', c', session_id)

  /// Validates the inner cookie data (use validate' for simplicity) and
  /// returns true if the calculated HMAC matches the given HMAC.
  let validate server_key request session_id hmac_given =
    let hmac_calc =
      hmac_data session_id request
      |> Crypto.hmac' server_key
      |> Utils.base64_headers
    String.cnst_time_cmp_ord hmac_given hmac_calc

  /// Validates the one server-side cookie that can be generated with 'generate_cookies',
  /// and returns the HttpCookie, session id string and given hmac value if it's all
  /// valid.
  let validate' ({runtime = { server_key = key }; request = req } as ctx : HttpContext) =
    let cookies =
      ctx
      |> HttpContext.request
      |> HttpRequest.cookies

    cookies
    |> Map.tryFind SessionAuthCookie
    |> Option.bind (fun auth_cookie ->
        parse_cookie_data auth_cookie.value
        |> Option.map (fun x -> auth_cookie, x))
    |> Option.bind (fun (auth_cookie, (session_id, hmac_given)) ->
        if validate key req session_id hmac_given then
          Some (auth_cookie, session_id, hmac_given)
        else None)

  /// Ensure the client/http context has a valid session id
  let authenticate (relative_expiry : TimeSpan) : WebPart =
    context (fun ctx ->
      match validate' ctx with
      | Some (a, session_id, _) ->  
        refresh_cookies relative_expiry a session_id
      | None   -> never)

  /// Set server-signed cookies to make the response contain a cookie
  /// with a valid session id
  let authenticated (relative_expiry : TimeSpan) : WebPart =
    context (fun ctx ->
      set_cookies (generate_cookies relative_expiry ctx))

/// TODO: provide abstraction over MemoryCache
module State =

  let ensure (storage : MemoryCache)
             (ctx     : HttpContext) =

    match Auth.validate' ctx with
    | Some (auth_cookie, session_id, hmac_given) as res when storage.Contains session_id ->
      succeed ctx
    | Some 
    | _ -> None

  let authenticated (storage : MemoryCache)
                    (ctx     : HttpContext) =
    match validate storage with

  let ensure (storage : MemoryCache)
             ({ request = req; runtime = { state_provider = sp } } as ctx) =
    
    let cookies = req |> HttpRequest.cookies




    let session_id =
      match look_up cookies SessionIdStateKey with
      | Some cookie ->
        if ctx.runtime.state_provider.Validate (attr, ctx) then
          cookie
        else
          ctx.runtime.state_provider.Generate (time_span, ctx)
      | None ->
        ctx.runtime.state_provider.Generate (time_span, ctx)

    set_session session_id time_span)
    let session_id = Crypto.generate_key' SessionIdLength
    let dict = new ConcurrentDictionary<string, obj> ()
    lock session_map (fun _ ->
        session_map.Add(session_id, dict :> obj,
                        Globals.utc_now().Add expiration)
        |> ignore)
      let hmac_data = Utils.hmac_data session_id ctx.request
      String.Concat [ session_id; (Crypto.hmac' key hmac_data |> Utils.base64_headers) ]


open Stateless
open Stateful

/// TODO: same as HttpContext.session below??
let get_session (session_map : MemoryCache) session_id =
  let state_bag = 
    lock session_map (fun _->
      if not (session_map.Contains session_id) then
        failwith "invalid session id."
      session_map.[session_id]) :?> ConcurrentDictionary<string, obj>
  let get = 
    fun s -> if state_bag.ContainsKey s then Some (state_bag.[s] :?> 'a) else None
  let set = fun s v -> state_bag.[s] <- v
  get, set

/// Extensions to HttpContext for Session support.
[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module HttpContext =

  /// Read the session store from the HttpContext, or throw an exception otherwise.
  /// If this throws an exception, it's a programming error from the consumer of the
  /// suave library.
  let state (ctx : HttpContext) : StateStore<'a> =
    match ctx.user_state |> Map.tryFind SessionIdStateKey with
    | Some x when x :? String && not (String.IsNullOrWhiteSpace (x :?> string)) ->
      ctx.runtime.state_provider.Session (x :?> string)
    | _ ->
      failwith "session_support was not called (or this is a load-balanced node w/ default impl)"

/// The default session provider is an in-process session state provider
type DefaultSessionProvider() =

  let key = Crypto.generate_key' ServerKeyLength
  let session_map = MemoryCache.Default

  interface SessionStateProvider with
    member this.Generate(expiration : TimeSpan, ctx : HttpContext) =
      Stateful.ensure session_map expiration ctx

    member this.Validate(cookie : HttpCookie, ctx : HttpContext) =
      validate session_map key cookie.value ctx

    member this.Session(s : string)  =
      get_session session_map (s.Substring(0, SessionIdLength))
