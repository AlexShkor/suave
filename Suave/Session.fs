/// The session module has two components; the stateless 'authed' component
/// which sets a http-only cookie and verifies its signature/hmac matches that
/// which is generated by the server, and another component, the stateless,
/// which also maintains a stateful Map<string, obj> of data for the user's
/// session id.
module Suave.Session

open System
open System.Collections.Concurrent
open System.Security.Cryptography
open System.Text
open System.Runtime.Caching
open Types
open Http

[<Literal>]
let ServerKeyLength = 64

[<Literal>]
let SessionIdLength = 40

[<Literal>]
let SessionHttpCookie = "suave_session_id"

/// This is the cookie that the client-side can use to check whether the
/// user is logged on or not. It's only a marker, which is used for this
/// purpose; the real auth cookie is the SessionHttpCookie, which isn't
/// available to client-side.
[<Literal>]
let SessionJsCookie = "suave_session_enabled"

/// The Id used in `context.user_state` to save the session id for downstream
/// web parts.
[<Literal>]
let SessionIdStateKey = "suave_session_id"

module internal Utils =
  /// This is used to pack base64 in a cookie; generates a degenerated base64 string
  let base64_headers bytes =
    let base64 = Convert.ToBase64String bytes
    base64.Replace('+','-').Replace('/','_').Trim([| '=' |])

  /// Extracts the actual session id and the mac value from the cookie's data.
  let parse_cookie_data (cd : string) =
    if cd.Length <= SessionIdLength then
      None
    else
      let id  = cd.Substring(0, SessionIdLength)
      let mac = cd.Substring(SessionIdLength)
      Some (id, mac)

  /// Returns a list of the hmac data to use, from the request.
  let hmac_data session_id (request : HttpRequest) =
    [ session_id
      request.ipaddr.ToString()
      (match request.headers %% "user-agent" with
      | None -> ""
      | Some ua -> ua)
    ]

let set_cookies (http_cookie, client_cookie) =
  Writers.set_cookie http_cookie >>=
    Writers.set_cookie client_cookie >>=
    Writers.set_user_data SessionIdStateKey (box http_cookie.value)

/// Use to validate, statelessly, whether the input from the web application is valid.
module Stateless =

  /// Generate one server-side cookie and one client-side cookie.
  let generate_cookies relative_expiry (ctx : HttpContext) =
    let session_id  = Crypto.generate_key' SessionIdLength
    let hmac_data   = Utils.hmac_data session_id ctx.request
    let hmac        = Crypto.hmac' ctx.runtime.server_key hmac_data |> Utils.base64_headers
    let cookie_data = String.Concat [| session_id; hmac |]
    let http_cookie, client_cookie =
      let expiry = Some (Globals.utc_now().Add relative_expiry)
      { HttpCookie.mk' SessionHttpCookie cookie_data with expires = expiry; http_only = true },
      { HttpCookie.mk' SessionJsCookie   "true"      with expires = expiry; http_only = false }
    http_cookie, client_cookie

  /// Sets the server-signed cookies
  let authenticated (relative_expiry : TimeSpan) (ctx : HttpContext) =
    set_cookies (generate_cookies relative_expiry ctx)

  /// Validates the inner cookie data (use validate' for simplicity)
  let validate server_key request session_id hmac_given =
    let hmac_calc =
      Utils.hmac_data session_id request
      |> Crypto.hmac' server_key
      |> Utils.base64_headers
    String.cnst_time_cmp_ord hmac_given hmac_calc

  /// Validates the one server-side cookie that can be generated with 'generate_cookies'
  let validate' (ctx : HttpContext) =
    let cookies = ctx |> HttpContext.request |> HttpRequest.cookies
    match cookies |> Map.tryFind SessionHttpCookie with
    | Some http_cookie ->
      match Utils.parse_cookie_data http_cookie.value with
      | None -> None
      | Some (session_id, hmac_given) ->
        if validate ctx.runtime.server_key ctx.request session_id hmac_given then
          Some (http_cookie, session_id, hmac_given)
        else
          None
    | _ ->  None

  let validate'' (ctx : HttpContext) =
    match validate' ctx with
    | Some _ -> ctx |> succeed
    | None -> fail

/// TODO: provide abstraction over MemoryCache
module Stateful =

  let validate (storage     : MemoryCache)
               (ctx         : HttpContext) =
    match Stateless.validate' http_cookie ctx with
    | Some (session_id, hmac_given) as res when storage.Contains session_id ->
      res
    | _ -> None

  let authenticated (storage : MemoryCache)
                    (ctx     : HttpContext) =
    match validate storage with

  let ensure (storage : MemoryCache)
             ({ request = req; runtime = { state_provider = sp } } as ctx) =
    
    let cookies = req |> HttpRequest.cookies




    let session_id =
      match look_up cookies SessionIdStateKey with
      | Some cookie ->
        if ctx.runtime.state_provider.Validate (attr, ctx) then
          cookie
        else
          ctx.runtime.state_provider.Generate (time_span, ctx)
      | None ->
        ctx.runtime.state_provider.Generate (time_span, ctx)

    set_session session_id time_span)
    let session_id = Crypto.generate_key' SessionIdLength
    let dict = new ConcurrentDictionary<string, obj> ()
    lock session_map (fun _ ->
        session_map.Add(session_id, dict :> obj,
                        Globals.utc_now().Add expiration)
        |> ignore)
      let hmac_data = Utils.hmac_data session_id ctx.request
      String.Concat [ session_id; (Crypto.hmac' key hmac_data |> Utils.base64_headers) ]


open Stateless
open Stateful

/// TODO: same as HttpContext.session below??
let get_session (session_map : MemoryCache) session_id =
  let state_bag = 
    lock session_map (fun _->
      if not (session_map.Contains session_id) then
        failwith "invalid session id."
      session_map.[session_id]) :?> ConcurrentDictionary<string, obj>
  let get = 
    fun s -> if state_bag.ContainsKey s then Some (state_bag.[s] :?> 'a) else None
  let set = fun s v -> state_bag.[s] <- v
  get, set

/// Extensions to HttpContext for Session support.
[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module HttpContext =

  /// Read the session store from the HttpContext, or throw an exception otherwise.
  /// If this throws an exception, it's a programming error from the consumer of the
  /// suave library.
  let state (ctx : HttpContext) : StateStore<'a> =
    match ctx.user_state |> Map.tryFind SessionIdStateKey with
    | Some x when x :? String && not (String.IsNullOrWhiteSpace (x :?> string)) ->
      ctx.runtime.state_provider.Session (x :?> string)
    | _ ->
      failwith "session_support was not called (or this is a load-balanced node w/ default impl)"

/// The default session provider is an in-process session state provider
type DefaultSessionProvider() =

  let key = Crypto.generate_key' ServerKeyLength
  let session_map = MemoryCache.Default

  interface SessionStateProvider with
    member this.Generate(expiration : TimeSpan, ctx : HttpContext) =
      Stateful.ensure session_map expiration ctx

    member this.Validate(cookie : HttpCookie, ctx : HttpContext) =
      validate session_map key cookie.value ctx

    member this.Session(s : string)  =
      get_session session_map (s.Substring(0, SessionIdLength))
