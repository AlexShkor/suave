/// The session module has two components; the stateless 'authed' component
/// which sets a http-only cookie and verifies its signature/hmac matches that
/// which is generated by the server, and another component, the stateless,
/// which also maintains a stateful Map<string, obj> of data for the user's
/// session id.
module Suave.Session

open System
open System.Collections.Concurrent
open System.Security.Cryptography
open System.Text
open System.Runtime.Caching
open Types
open Http

module Cookies =

  type Expiry =
    | SessionCookie
    | Expiry of TimeSpan

  type CookieError =
    | NoCookieFound of string (* cookie id *)
    | DecryptionError of Crypto.SecretboxDecryptionError

  let private client_cookie_from (http_cookie : HttpCookie) =
    let ccn = String.Concat [ http_cookie.name; "-client" ]
    { HttpCookie.mk' ccn http_cookie.name
        with http_only = false
             secure    = http_cookie.secure
             expires   = http_cookie.expires }

  /// Set +relative_expiry time span on the expiry time of the http cookie
  /// and generate a corresponding client-side cookie with the same expiry, that
  /// has as its data, the cookie name of the http cookie.
  let sliding_expiry (relative_expiry : Expiry) (http_cookie : HttpCookie) =
    let cookie_name = http_cookie.name
    let expiry =
      match relative_expiry with
      | SessionCookie -> None
      | Expiry ts  -> Some (Globals.utc_now().Add ts)
    let http_cookie = { http_cookie with expires = expiry }
    http_cookie, client_cookie_from http_cookie

  /// Generate one server-side cookie, and another client-side cookie with
  /// name "${server-side-name}-client"
  let generate_cookies key cookie_name relative_expiry secure plain_data =
    match Crypto.secretbox key plain_data with
    | Choice1Of2 cookie_data ->
      let encoded_data = Bytes.encode_safe_base64 cookie_data
      { HttpCookie.mk' cookie_name encoded_data
          with http_only = true
               secure = secure }
      |> sliding_expiry relative_expiry
    | err -> failwithf "internal error on encryption %A" err

  /// Tries to read the cookie of the given name from the HttpContext, and
  /// returns the cookie and its plaintext value if successful.
  let read_cookies key cookie_name ctx =
    let found =
      ctx.request
      |> HttpRequest.cookies
      |> Map.tryFind cookie_name
      |> Choice.from_option (NoCookieFound cookie_name)
      |> Choice.map (fun c -> c, c |> (HttpCookie.value >> Bytes.decode_safe_base64))
    match found with
    | Choice1Of2 (cookie, cipher_data) ->
      cipher_data
      |> Crypto.secretbox_open key
      |> Choice.map_2 DecryptionError
      |> Choice.map (fun plain_text -> cookie, plain_text)
    | Choice2Of2 x -> Choice2Of2 x

  /// Unsets the cookies, thereby unauthenticating the user.
  let unset_cookies (http_cookie : HttpCookie) : WebPart =
    Writers.unset_cookie http_cookie.name >>=
      Writers.unset_cookie (String.Concat [ http_cookie.name; "-client" ])

  /// Sets the cookies to the HttpResponse
  let set_cookies (http_cookie : HttpCookie) (client_cookie : HttpCookie) : WebPart =
    Writers.set_cookie http_cookie >>=
      Writers.set_cookie client_cookie

  /// Bumps the expiry dates for all the cookies and user_data value.
  let refresh_cookies relative_expiry http_cookie : WebPart =
    sliding_expiry relative_expiry http_cookie ||> set_cookies

  let cookie_state server_key
                   cookie_name
                   user_state_key
                   relative_expiry
                   secure
                   // unit -> plain text OR something of your own!
                   (no_cookie : unit -> Choice<string, WebPart>)
                   (failure   : _ -> WebPart)
                   : WebPart =
    context (fun ctx ->
      match read_cookies server_key cookie_name ctx with
      | Choice1Of2 (http_cookie, plain_text) ->
        refresh_cookies relative_expiry http_cookie >>=
          Writers.set_user_data user_state_key plain_text

      | Choice2Of2 (NoCookieFound _) ->
        match no_cookie () with
        | Choice1Of2 plain_text ->
          let http_cookie, client_cookie =
            generate_cookies server_key cookie_name relative_expiry secure plain_text
          set_cookies http_cookie client_cookie >>=
            Writers.set_user_data user_state_key plain_text
        | Choice2Of2 wp_kont -> wp_kont

      | Choice2Of2 (DecryptionError err) ->
        failure err)

/// Use to set a session-id for the client, which is a way is how the client
/// is 'authenticated'.
module Auth =

  open Cookies

  module internal Utils =
    /// Generates a string key from the available characters with the given key size
    /// in characters. Note that this key is not cryptographically as random as a pure
    /// random number generator would produce as we only use a small subset alphabet.
    let generate_readable_key (key_size : int) =
      let arr = Array.zeroCreate<byte> key_size |> Crypto.randomize
      let alpha = "abcdefghijklmnopqrstuvwuxyz0123456789"
      let result = new StringBuilder(key_size)
      arr
      |> Array.iter (fun (b : byte) -> result.Append alpha.[int b % alpha.Length] |> ignore)
      result.ToString()

  [<Literal>]
  let SessionAuthCookie = "auth"

  /// The key used in `context.user_state` to save the session id for downstream
  /// web parts.
  [<Literal>]
  let UserStateKey = "Suave.Session.Auth"

  [<Literal>]
  let SessionIdLength = 40

  /// Extracts the actual session id and the mac value from the cookie's data.
  let parse_data (text_blob : string) =
    match text_blob.Split '\n' with
    | [| session_id; ip_address; user_agent |] ->
      session_id
    | _ -> failwith "internal error; should not have successfully decrypted data"

  /// Returns a list of the hmac data to use, from the request.
  let generate_data (request : HttpRequest) =
    let session_id = Utils.generate_readable_key SessionIdLength
    String.concat "\n"
      [ session_id
        request.ipaddr.ToString()
        request.headers %% "user-agent" |> Option.or_default ""
      ]

  let authenticate relative_expiry secure
                   missing_cookie
                   (failure : Crypto.SecretboxDecryptionError -> WebPart)
                   : WebPart =
    context (fun ({runtime = { server_key = key }} as ctx : HttpContext) ->
      Cookies.cookie_state key
                           SessionAuthCookie UserStateKey
                           relative_expiry
                           secure
                           missing_cookie
                           failure)

  let authenticate' relative_expiry login_page : WebPart =
    authenticate relative_expiry false
      (fun () -> Choice2Of2(Redirection.FOUND login_page))
      (sprintf "%A" >> RequestErrors.BAD_REQUEST)

  /// Set server-signed cookies to make the response contain a cookie
  /// with a valid session id. It's worth having in mind that when you use this web
  /// part, you're setting cookies on the response; so you'll need to have the
  /// client re-send a request if you require authentication for it, after this
  /// web part has run.
  ///
  /// Parameters:
  ///  - `relative_expiry`: how long does the authentication cookie last?
  /// - `secure`: HttpsOnly?
  let authenticated relative_expiry secure : WebPart =
    context (fun { request = req } ->
      authenticate relative_expiry secure
                   (fun () -> Choice1Of2(generate_data req))
                   (sprintf "%A" >> RequestErrors.BAD_REQUEST))
    
  module HttpContext =
    let session_id x =
      x.user_state
      |> Map.tryFind UserStateKey
      |> Option.map (fun x -> x :?> string |> parse_data)

/// Common for this module is that it requires that the Auth module
/// above has been activated/used and that the user is authenticated.
module State =

  /// We basically want this:
  /// http://nacl.cr.yp.to/secretbox.html
  [<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
  module CookieStateStore =

    /// This key will be present in HttpContext.user_state and will contain the
    /// MemoryCache instance.
    [<Literal>]
    let StateStoreType = "Suave.Session.State.CookieStateStore"

    [<Literal>]
    let StateCookie = "st"

    ()

  /// This module contains the implementation for the memory-cache backed session
  /// state store, when the memory cache is global for the server.
  [<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
  module MemoryCacheStateStore =

    /// This key will be present in HttpContext.user_state and will contain the
    /// MemoryCache instance.
    [<Literal>]
    let StateStoreType = "Suave.Session.State.MemoryCacheStateStore"

    [<Literal>]
    let UserStateKey = "Suave.Session.Auth"

    [<Literal>]
    let StateCookie = "mc-st"

    module HttpContext =

      /// Try to find the state id of the HttpContext
      let state_id ctx =
        ctx.user_state
        |> Map.tryFind UserStateKey
        |> Option.map (fun x -> x :?> string)
  
      /// Read the session store from the HttpContext, or throw an exception otherwise.
      /// If this throws an exception, it's a programming error from the consumer of the
      /// suave library.
      let state (ctx : HttpContext) =
        ctx.user_state
        |> Map.tryFind StateStoreType
        |> Option.map (fun ss -> ss :?> StateStore)

    let private wrap (session_map : MemoryCache) relative_expiry session_id =
      let exp = function
        | Cookies.SessionCookie -> CacheItemPolicy()
        | Cookies.Expiry ts     -> CacheItemPolicy(SlidingExpiration = ts)

      let state_bag =
        lock session_map (fun _->
          if session_map.Contains session_id then
            session_map.Get session_id
            :?> ConcurrentDictionary<string, obj>
          else
            let cd = new ConcurrentDictionary<string, obj>()
            session_map.Set(CacheItem(session_id, cd), exp relative_expiry)
            cd)

      { new StateStore with
          member x.get key       =
            if state_bag.ContainsKey key then
              Some (state_bag.[key] :?> 'a)
            else None
          member x.set key value =
            state_bag.[key] <- value }

    let stateful relative_expiry : WebPart =
      let state_store = wrap (MemoryCache.Default) relative_expiry

      context (fun ctx ->
        match ctx |> HttpContext.state with
        | None       ->
          let state_id = ctx |> HttpContext.state_id |> Option.get
          Writers.set_user_data StateStoreType (state_store state_id)
        | Some store ->
          succeed)

    let DefaultExpiry = TimeSpan.FromMinutes 30. |> Cookies.Expiry