/// The session module has two components; the stateless 'authed' component
/// which sets a http-only cookie and verifies its signature/hmac matches that
/// which is generated by the server, and another component, the stateless,
/// which also maintains a stateful Map<string, obj> of data for the user's
/// session id.
module Suave.Session

open System
open System.Collections.Concurrent
open System.Security.Cryptography
open System.Text
open System.Runtime.Caching

open Suave.Types
open Suave.Http
open Suave.Log

let private log (logger : Logger) path level msg =
  LogLine.mk path level TraceHeader.empty None msg
  |> fun line -> logger.Log level (fun () -> line)

module Cookies =

  type Expiry =
    | SessionCookie
    | Expiry of TimeSpan

  type CookieError =
    | NoCookieFound of string (* cookie id *)
    | DecryptionError of Crypto.SecretboxDecryptionError

  let private client_cookie_from (http_cookie : HttpCookie) =
    let ccn = String.Concat [ http_cookie.name; "-client" ]
    { HttpCookie.mk' ccn http_cookie.name
        with http_only = false
             secure    = http_cookie.secure
             expires   = http_cookie.expires }

  /// Set +relative_expiry time span on the expiry time of the http cookie
  /// and generate a corresponding client-side cookie with the same expiry, that
  /// has as its data, the cookie name of the http cookie.
  let private sliding_expiry (relative_expiry : Expiry) (http_cookie : HttpCookie) =
    let cookie_name = http_cookie.name
    let expiry =
      match relative_expiry with
      | SessionCookie -> None
      | Expiry ts  -> Some (Globals.utc_now().Add ts)
    let http_cookie = { http_cookie with expires = expiry }
    http_cookie, client_cookie_from http_cookie

  /// Unsets the cookies, thereby unauthenticating the user.
  let internal unset_cookies http_cookie_name : WebPart =
    Writers.unset_cookie http_cookie_name >>=
      Writers.unset_cookie (String.Concat [ http_cookie_name; "-client" ])

  /// Sets the cookies to the HttpResponse
  let internal set_cookies (http_cookie : HttpCookie) (client_cookie : HttpCookie) : WebPart =
    Writers.set_cookie http_cookie >>=
      Writers.set_cookie client_cookie

  type CookiesState =
    { server_key      : byte []
      cookie_name     : string
      user_state_key  : string
      relative_expiry : Expiry
      secure          : bool }

  [<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
  module CookiesState =

    let mk server_key cookie_name user_state_key relative_expiry secure =
      { server_key      = server_key
        cookie_name     = cookie_name
        user_state_key  = user_state_key
        relative_expiry = relative_expiry
        secure          = secure }

  /// Generate one server-side cookie, and another client-side cookie with
  /// name "${server-side-name}-client"
  let generate_cookies server_key cookie_name relative_expiry secure plain_data =
    let enc, _ = Bytes.cookie_encoding
    match Crypto.secretbox server_key plain_data with
    | Choice1Of2 cookie_data ->
      let encoded_data = enc cookie_data
      { HttpCookie.mk' cookie_name encoded_data
          with http_only = true
               secure    = secure }
      |> sliding_expiry relative_expiry
    | err -> failwithf "internal error on encryption %A" err

  /// Tries to read the cookie of the given name from the HttpContext, and
  /// returns the cookie and its plaintext value if successful.
  let read_cookies key cookie_name ctx =
    let _, dec = Bytes.cookie_encoding
    let found =
      ctx.request
      |> HttpRequest.cookies
      |> Map.tryFind cookie_name
      |> Choice.from_option (NoCookieFound cookie_name)
      |> Choice.map (fun c -> c, c |> (HttpCookie.value >> dec))
    match found with
    | Choice1Of2 (cookie, cipher_data) ->
      cipher_data
      |> Crypto.secretbox_open key
      |> Choice.map_2 DecryptionError
      |> Choice.map (fun plain_text -> cookie, plain_text)
    | Choice2Of2 x -> Choice2Of2 x

  /////////////// WEB PARTS ////////////////

  /// Bumps the expiry dates for all the cookies.
  let refresh_cookies relative_expiry http_cookie : WebPart =
    sliding_expiry relative_expiry http_cookie ||> set_cookies

  let update_cookies (csctx : CookiesState) f_plain_text : WebPart =
    context (fun ({ runtime = { logger = logger }} as ctx) ->
      let plain_text' =
        match read_cookies csctx.server_key csctx.cookie_name ctx with
        | Choice1Of2 (_, plain_text) ->
          log logger "Suave.Session.Cookies.update_cookies" Debug
            (sprintf "update_cookies - existing value: '%s'" (plain_text |> UTF8.to_string'))
          f_plain_text (Some plain_text)
        | Choice2Of2 _ ->
          log logger "Suave.Session.Cookies.update_cookies" Debug "update_cookies - first time"
          f_plain_text None

      log logger "Suave.Session.Cookies.update_cookies" Debug
        (sprintf "update_cookies - setting '%s'"
          (plain_text' |> UTF8.to_string'))
      /// Since the contents will completely change every write, we simply re-generate the cookie
      generate_cookies csctx.server_key csctx.cookie_name
                       csctx.relative_expiry csctx.secure
                       plain_text'
      ||> set_cookies
      >>= Writers.set_user_data csctx.user_state_key plain_text')

  let cookie_state (csctx : CookiesState)
                   // unit -> plain text to store OR something to run of your own!
                   (no_cookie : unit -> Choice<byte [], WebPart>)
                   (decryption_failure   : _ -> WebPart)
                   : WebPart =
    context (fun ({ runtime = { logger = logger }} as ctx) ->
      match read_cookies csctx.server_key csctx.cookie_name ctx with
      | Choice1Of2 (http_cookie, plain_text) ->
        refresh_cookies csctx.relative_expiry http_cookie >>=
          Writers.set_user_data csctx.user_state_key plain_text

      | Choice2Of2 (NoCookieFound _) ->
        match no_cookie () with
        | Choice1Of2 plain_text ->
          log logger "Suave.Session.Cookies.cookie_state" Debug
            (sprintf "setting '%s' with value '%s'" csctx.cookie_name (UTF8.to_string' plain_text))
          let http_cookie, client_cookie =
            generate_cookies csctx.server_key csctx.cookie_name
                             csctx.relative_expiry csctx.secure
                             plain_text
          set_cookies http_cookie client_cookie >>=
            Writers.set_user_data csctx.user_state_key plain_text
        | Choice2Of2 wp_kont -> wp_kont

      | Choice2Of2 (DecryptionError err) ->
        log logger "Suave.Session.Cookies.cookie_state" Debug
          (sprintf "decryption error: %A" err)
        unset_cookies csctx.cookie_name >>=
          decryption_failure err)

/// Use to set a session-id for the client, which is a way is how the client
/// is 'authenticated'.
module Auth =

  open Cookies

  module internal Utils =
    /// Generates a string key from the available characters with the given key size
    /// in characters. Note that this key is not cryptographically as random as a pure
    /// random number generator would produce as we only use a small subset alphabet.
    let generate_readable_key (key_size : int) =
      let arr = Array.zeroCreate<byte> key_size |> Crypto.randomize
      let alpha = "abcdefghijklmnopqrstuvwuxyz0123456789"
      let result = new StringBuilder(key_size)
      arr
      |> Array.iter (fun (b : byte) -> result.Append alpha.[int b % alpha.Length] |> ignore)
      result.ToString()

  [<Literal>]
  let SessionAuthCookie = "auth"

  /// The key used in `context.user_state` to save the session id for downstream
  /// web parts.
  [<Literal>]
  let StateStoreType = "Suave.Session.Auth"

  [<Literal>]
  let SessionIdLength = 40

  /// Extracts the actual session id and the mac value from the cookie's data.
  let parse_data (text_blob : string) =
    match text_blob.Split '\n' with
    | [| session_id; ip_address; user_agent |] ->
      session_id
    | _ -> failwith "internal error; should not have successfully decrypted data"

  /// Returns a list of the hmac data to use, from the request.
  let generate_data (request : HttpRequest) =
    let session_id = Utils.generate_readable_key SessionIdLength
    String.concat "\n"
      [ session_id
        request.ipaddr.ToString()
        request.headers %% "user-agent" |> Option.or_default ""
      ]

  let authenticate relative_expiry secure
                   missing_cookie
                   (failure : Crypto.SecretboxDecryptionError -> WebPart)
                   : WebPart =
    context (fun ({ runtime = { logger = logger }} as ctx) ->
      log logger "Suave.Session.Auth.authenticate" Debug "authenticating"

      Cookies.cookie_state
        { server_key      = ctx.runtime.server_key
          cookie_name     = SessionAuthCookie
          user_state_key  = StateStoreType
          relative_expiry = relative_expiry
          secure          = secure }
        missing_cookie
        failure)

  let authenticate' relative_expiry login_page : WebPart =
    authenticate relative_expiry false
                 (fun () -> Choice2Of2(Redirection.FOUND login_page))
                 (sprintf "%A" >> RequestErrors.BAD_REQUEST)

  /// Set server-signed cookies to make the response contain a cookie
  /// with a valid session id. It's worth having in mind that when you use this web
  /// part, you're setting cookies on the response; so you'll need to have the
  /// client re-send a request if you require authentication for it, after this
  /// web part has run.
  ///
  /// Parameters:
  ///  - `relative_expiry`: how long does the authentication cookie last?
  /// - `secure`: HttpsOnly?
  let authenticated relative_expiry secure : WebPart =
    context (fun { request = req } ->
      authenticate relative_expiry secure
                   (fun () -> Choice1Of2(generate_data req |> UTF8.bytes))
                   (sprintf "%A" >> RequestErrors.BAD_REQUEST))

//  let deauthenticate : WebPart =
//    Cookies.unset_cookies
    
  module HttpContext =

    let session_id x =
      x.user_state
      |> Map.tryFind StateStoreType
      |> Option.map (fun x -> x :?> string |> parse_data)

/// Common for this module is that it requires that the Auth module
/// above has been activated/used and that the user is authenticated.
module State =

  [<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
  module CookieStateStore =
    open System.IO
    open System.Runtime.Serialization.Json
    open System.Collections.Generic

    /// "Suave.Session.State.CookieStateStore"
    [<Literal>]
    let StateStoreType = "Suave.Session.State.CookieStateStore"

    /// "st"
    [<Literal>]
    let StateCookie = "st"

    let encode_map m =
      let dcs = DataContractJsonSerializer(m.GetType())
      use ms = new MemoryStream()
      dcs.WriteObject(ms, m)
      ms.ToArray()

    let decode_map bytes =
      let dcs = DataContractJsonSerializer(typeof<Dictionary<string, string>>)
      use ms = new MemoryStream()
      ms.Write(bytes, 0, bytes.Length)
      ms.Seek(0L, SeekOrigin.Begin) |> ignore
      dcs.ReadObject(ms) :?> Dictionary<string, string>

    // TODO: this is a buggy proof of concept serialisation from .Net, consider
    // reworking it to e.g. Fleece
    let write relative_expiry key value =
      context (fun ({ runtime = { logger = logger }} as ctx) ->
        log logger "Suave.Session.State.CookieStateStore.write" Debug 
          (sprintf "updating key '%s' with value '%s'" key value)
        Cookies.update_cookies
          { server_key      = ctx.runtime.server_key
            cookie_name     = StateCookie
            user_state_key  = StateStoreType
            relative_expiry = relative_expiry
            secure          = false }
          (function
           | None ->
             let d = Dictionary<string, string>()
             d.Add (key, value)
             encode_map d
           | Some obj_str ->
             let d = decode_map obj_str
             d.Add (key, value)
             encode_map d))

    let stateful relative_expiry secure : WebPart =
      context (fun ctx ->
        Cookies.cookie_state
          { server_key      = ctx.runtime.server_key
            cookie_name     = StateCookie
            user_state_key  = StateStoreType
            relative_expiry = relative_expiry
            secure          = secure }
          (fun () -> Choice1Of2("{}" |> UTF8.bytes))
          (sprintf "%A" >> RequestErrors.BAD_REQUEST))
      >>= Writers.set_user_data (StateStoreType + "-expiry") relative_expiry

    ///
    ///
    /// Only save the state for the duration of the browser session.
    let stateful' : WebPart =
      stateful Cookies.SessionCookie false

    module HttpContext =

      let private mk_state_store (user_state : Map<string, obj>) (ss : obj) =
        { new StateStore with
            member x.get key =
              let m = decode_map (ss :?> byte [])
              match m.TryGetValue key with
              | false, _ -> None
              | true, value -> Some value
              |> Option.map (fun x -> Convert.ChangeType(x, typeof<'a>) :?> 'a)
            member x.set key value =
              let expiry = user_state |> Map.find (StateStoreType + "-expiry") :?> Cookies.Expiry
              write expiry key (value.ToString()) // TODO: handle gratiously all types of values
              }
  
      /// Read the session store from the HttpContext.
      let state (ctx : HttpContext) =
        ctx.user_state
        |> Map.tryFind StateStoreType
        |> Option.map (mk_state_store ctx.user_state)

  /// This module contains the implementation for the memory-cache backed session
  /// state store, when the memory cache is global for the server.
  [<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
  module MemoryCacheStateStore =

    /// This key will be present in HttpContext.user_state and will contain the
    /// MemoryCache instance.
    [<Literal>]
    let StateStoreType = "Suave.Session.State.MemoryCacheStateStore"

    [<Literal>]
    let UserStateIdKey = "Suave.Session.State.MemoryCacheStateStore-id"

    [<Literal>]
    let StateCookie = "mc-st"

    module HttpContext =

      /// Try to find the state id of the HttpContext.
      let state_id ctx =
        ctx.user_state
        |> Map.tryFind UserStateIdKey
        |> Option.map (fun x -> x :?> string)
        |> Option.get
  
      /// Read the session store from the HttpContext.
      let state (ctx : HttpContext) =
        ctx.user_state
        |> Map.tryFind StateStoreType
        |> Option.map (fun ss -> ss :?> StateStore)
        |> Option.get
        
    let private wrap (session_map : MemoryCache) relative_expiry session_id =
      let exp = function
        | Cookies.SessionCookie -> CacheItemPolicy()
        | Cookies.Expiry ts     -> CacheItemPolicy(SlidingExpiration = ts)

      let state_bag =
        lock session_map (fun _->
          if session_map.Contains session_id then
            session_map.Get session_id
            :?> ConcurrentDictionary<string, obj>
          else
            let cd = new ConcurrentDictionary<string, obj>()
            session_map.Set(CacheItem(session_id, cd), exp relative_expiry)
            cd)

      { new StateStore with
          member x.get key =
            if state_bag.ContainsKey key then
              Some (state_bag.[key] :?> 'a)
            else None
          member x.set key value =
            state_bag.[key] <- value
            succeed }

    let stateful relative_expiry : WebPart =
      let state_store = wrap (MemoryCache.Default) relative_expiry
      context (fun ctx ->
        let state_id = ctx |> HttpContext.state_id
        Writers.set_user_data StateStoreType (state_store state_id))

    let DefaultExpiry = TimeSpan.FromMinutes 30. |> Cookies.Expiry